<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>PHEN-228: THE BOILED ONE</title>
<style>
    body {
        margin: 0;
        background-color: #000;
        overflow: hidden;
        touch-action: none;
        font-family: 'Courier New', Courier, monospace;
        user-select: none;
        -webkit-user-select: none;
    }
    #gameCanvas {
        display: block;
        width: 100%;
        height: 100%;
        image-rendering: pixelated;
        filter: contrast(1.2) brightness(0.8) sepia(0.2);
    }
    /* VHS EFFECTS */
    .overlay {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none;
        background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
        background-size: 100% 4px, 6px 100%;
        z-index: 5;
    }
    .vignette {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none;
        background: radial-gradient(circle, transparent 50%, black 100%);
        z-index: 6;
    }
    #start-screen, #death-screen {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 100;
        background: #000;
        color: #d00;
        text-align: center;
    }
    #death-screen { display: none; overflow: hidden; }
    h1 { font-size: 40px; margin: 0; text-shadow: 2px 2px 0px red; }
    p { color: white; margin-top: 10px; animation: blink 1s infinite; }
    @keyframes blink { 0% {opacity:1;} 50% {opacity:0.2;} 100% {opacity:1;} }
    
    /* Control Hint Indicators */
    .stick-zone {
        position: absolute;
        bottom: 50px;
        width: 100px;
        height: 100px;
        border: 2px dashed rgba(255,255,255,0.2);
        border-radius: 50%;
        pointer-events: none;
        display: flex;
        justify-content: center;
        align-items: center;
        color: rgba(255,255,255,0.3);
        font-size: 10px;
    }
    #left-zone { left: 40px; }
    #right-zone { right: 40px; }
</style>
</head>
<body>

<div id="start-screen">
    <h1 style="color:red">PHEN-228</h1>
    <p>TAP TO INITIALIZE BROADCAST</p>
    <small style="color:#555; margin-top:20px;">Use Headphones</small>
</div>

<div id="death-screen">
    <h1 id="death-text">PARALYSIS</h1>
</div>

<canvas id="gameCanvas"></canvas>
<div class="overlay"></div>
<div class="vignette"></div>

<div id="left-zone" class="stick-zone">MOVE</div>
<div id="right-zone" class="stick-zone">LOOK</div>

<script>
    // --- AUDIO ENGINE (Web Audio API) ---
    const Audio = (function() {
        let ctx = null;
        let droneNode = null;
        
        function init() {
            if (!ctx) {
                ctx = new (window.AudioContext || window.webkitAudioContext)();
                
                // Horror Drone (Low frequency oscillating)
                droneNode = ctx.createOscillator();
                droneNode.type = 'sawtooth';
                droneNode.frequency.value = 50;
                
                const gain = ctx.createGain();
                gain.gain.value = 0.05;
                
                const filter = ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 200;

                droneNode.connect(filter);
                filter.connect(gain);
                gain.connect(ctx.destination);
                droneNode.start();
                
                // LFO to wobble the drone
                const lfo = ctx.createOscillator();
                lfo.type = 'sine';
                lfo.frequency.value = 0.5;
                const lfoGain = ctx.createGain();
                lfoGain.gain.value = 50;
                lfo.connect(lfoGain);
                lfoGain.connect(filter.frequency);
                lfo.start();
            }
            if (ctx.state === 'suspended') ctx.resume();
        }

        function playScream() {
            if (!ctx) return;
            const osc = ctx.createOscillator();
            osc.type = 'sawtooth';
            // Glitchy frequency sweep
            osc.frequency.setValueAtTime(100, ctx.currentTime);
            osc.frequency.linearRampToValueAtTime(1500, ctx.currentTime + 0.1);
            osc.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 1.5);

            const gain = ctx.createGain();
            gain.gain.setValueAtTime(0.5, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 1.5);

            // Distortion
            const shaper = ctx.createWaveShaper();
            function makeDistortionCurve(amount) {
                let k = typeof amount === 'number' ? amount : 50,
                    n_samples = 44100,
                    curve = new Float32Array(n_samples),
                    deg = Math.PI / 180,
                    i = 0, x;
                for ( ; i < n_samples; ++i ) {
                    x = i * 2 / n_samples - 1;
                    curve[i] = ( 3 + k ) * x * 20 * deg / ( Math.PI + k * Math.abs(x) );
                }
                return curve;
            }
            shaper.curve = makeDistortionCurve(400);

            osc.connect(shaper);
            shaper.connect(gain);
            gain.connect(ctx.destination);
            osc.start();
            osc.stop(ctx.currentTime + 2);
        }

        return { init, playScream };
    })();

    // --- GRAPHICS SETUP ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    
    // Resolution: Low = Retro & Fast
    const W = 240; 
    const H = 180;
    canvas.width = W;
    canvas.height = H;

    // --- ASSET GENERATION: THE BOILED ONE ---
    // Procedurally drawing Phen-228's face
    const spriteSize = 128;
    const monsterCanvas = document.createElement('canvas');
    monsterCanvas.width = spriteSize;
    monsterCanvas.height = spriteSize;
    const mCtx = monsterCanvas.getContext('2d');

    function drawMonster() {
        const c = mCtx;
        // Base Skin (Burnt Red/Brown)
        c.fillStyle = '#4a0e0e';
        c.beginPath();
        c.ellipse(64, 64, 40, 55, 0, 0, Math.PI*2);
        c.fill();
        
        // Highlights (Melted flesh)
        c.fillStyle = '#6e1a1a';
        c.beginPath();
        c.ellipse(50, 50, 10, 20, 0.2, 0, Math.PI*2);
        c.fill();
        c.beginPath();
        c.ellipse(78, 55, 8, 15, -0.2, 0, Math.PI*2);
        c.fill();

        // Eyes (Wide, staring, bloodshot)
        c.fillStyle = '#000'; // Sockets
        c.beginPath();
        c.arc(45, 55, 12, 0, Math.PI*2);
        c.arc(83, 55, 12, 0, Math.PI*2);
        c.fill();

        c.fillStyle = '#fff'; // Eyeball
        c.beginPath();
        c.arc(45, 55, 6, 0, Math.PI*2);
        c.arc(83, 55, 6, 0, Math.PI*2);
        c.fill();
        
        c.fillStyle = '#000'; // Pupil (Tiny)
        c.beginPath();
        c.arc(45, 55, 1, 0, Math.PI*2);
        c.arc(83, 55, 1, 0, Math.PI*2);
        c.fill();

        // Mouth (The Smile)
        c.fillStyle = '#1a0000';
        c.beginPath();
        c.moveTo(40, 90);
        c.quadraticCurveTo(64, 110, 88, 90); // Smile bottom
        c.quadraticCurveTo(64, 95, 40, 90);  // Smile top
        c.fill();
        
        // Teeth (Yellowed)
        c.fillStyle = '#aa8';
        for(let i=0; i<5; i++) {
            c.fillRect(45 + i*8, 92, 4, 4);
        }
    }
    drawMonster();

    // --- GAME ENGINE ---
    const BLOCK = 64;
    const FOV = Math.PI / 2.5;
    const ZBUFFER = new Float32Array(W);
    const MAP_DIM = 24; // BIG MAP

    // 0=Empty, 1=Wall
    let map = [];
    // Generate a large hall with pillars
    for(let y=0; y<MAP_DIM; y++) {
        for(let x=0; x<MAP_DIM; x++) {
            // Border walls
            if(x===0 || x===MAP_DIM-1 || y===0 || y===MAP_DIM-1) {
                map.push(1);
            } 
            // Random pillars, but leave center open
            else if (Math.random() > 0.85 && (x < 8 || x > 16 || y < 8 || y > 16)) {
                map.push(1);
            } else {
                map.push(0);
            }
        }
    }

    let player = { x: BLOCK*2, y: BLOCK*2, dir: 0.5 };
    let enemy = { x: BLOCK*12, y: BLOCK*12 };
    let frame = 0;
    let gameState = 'START'; // START, PLAY, DEAD

    // --- INPUTS ---
    let touchL = { active:false, x:0, y:0, dx:0, dy:0, id: -1 };
    let touchR = { active:false, x:0, y:0, dx:0, dy:0, id: -1 };
    const STICK_MAX = 50;

    window.addEventListener('touchstart', e => {
        if(gameState === 'START') {
            Audio.init();
            gameState = 'PLAY';
            document.getElementById('start-screen').style.display = 'none';
        }
        if(gameState === 'DEAD') {
             location.reload(); 
        }

        e.preventDefault();
        for(let i=0; i<e.changedTouches.length; i++) {
            let t = e.changedTouches[i];
            if(t.clientX < window.innerWidth/2) {
                if(!touchL.active) {
                    touchL.active = true; touchL.id = t.identifier;
                    touchL.x = t.clientX; touchL.y = t.clientY;
                }
            } else {
                if(!touchR.active) {
                    touchR.active = true; touchR.id = t.identifier;
                    touchR.x = t.clientX; touchR.y = t.clientY;
                }
            }
        }
    }, {passive:false});

    window.addEventListener('touchmove', e => {
        e.preventDefault();
        for(let i=0; i<e.changedTouches.length; i++) {
            let t = e.changedTouches[i];
            if(touchL.active && t.identifier === touchL.id) {
                touchL.dx = t.clientX - touchL.x;
                touchL.dy = t.clientY - touchL.y;
            }
            if(touchR.active && t.identifier === touchR.id) {
                touchR.dx = t.clientX - touchR.x;
                touchR.dy = t.clientY - touchR.y;
            }
        }
    }, {passive:false});

    window.addEventListener('touchend', e => {
        e.preventDefault();
        for(let i=0; i<e.changedTouches.length; i++) {
            let t = e.changedTouches[i];
            if(t.identifier === touchL.id) { touchL.active = false; touchL.dx=0; touchL.dy=0; }
            if(t.identifier === touchR.id) { touchR.active = false; touchR.dx=0; touchR.dy=0; }
        }
    });

    // --- RENDER LOOP ---
    function loop() {
        if(gameState === 'PLAY') {
            update();
            render();
        } else if (gameState === 'DEAD') {
            renderDeath();
        }
        requestAnimationFrame(loop);
    }

    function update() {
        frame++;
        
        // Move
        if(touchL.active) {
            // Normalize stick vector
            let dist = Math.sqrt(touchL.dx*touchL.dx + touchL.dy*touchL.dy);
            let speed = Math.min(dist, STICK_MAX) / STICK_MAX; // 0 to 1
            let angle = Math.atan2(touchL.dy, touchL.dx);
            
            // Move relative to player direction
            // Joy Up (negative Y) should mean move Forward
            // We map Joystick angle to Player Direction
            // forward vector = player.dir
            
            let moveSpeed = 4.0 * speed;
            // The joystick angle is absolute on screen. We need to convert "Up" on screen to "Forward" in world
            let moveDir = player.dir + angle + (Math.PI/2); 

            let nx = player.x + Math.cos(moveDir) * moveSpeed;
            let ny = player.y + Math.sin(moveDir) * moveSpeed;

            if(map[Math.floor(ny/BLOCK)*MAP_DIM + Math.floor(nx/BLOCK)] === 0) {
                player.x = nx; player.y = ny;
            }
        }

        // Look
        if(touchR.active) {
            let turn = (touchR.dx / STICK_MAX) * 0.08;
            player.dir += turn;
        }

        // MONSTER AI
        let dx = player.x - enemy.x;
        let dy = player.y - enemy.y;
        let dist = Math.sqrt(dx*dx + dy*dy);

        // Speed increases as he gets closer (The Boiled One Effect)
        let enemySpeed = dist > 300 ? 1.5 : 2.5; 
        
        enemy.x += (dx/dist) * enemySpeed;
        enemy.y += (dy/dist) * enemySpeed;

        // Glitch effect logic
        if(dist < 200 && Math.random() > 0.9) {
            canvas.style.transform = `translate(${Math.random()*10-5}px, ${Math.random()*10-5}px)`;
            canvas.style.filter = "invert(1)";
        } else {
            canvas.style.transform = "none";
            canvas.style.filter = "contrast(1.2) brightness(0.8) sepia(0.2)";
        }

        if(dist < 30) {
            gameState = 'DEAD';
            Audio.playScream();
            document.getElementById('death-screen').style.display = 'flex';
        }
    }

    function render() {
        // Floor/Ceiling
        ctx.fillStyle = '#050505';
        ctx.fillRect(0, 0, W, H);
        
        // Raycasting
        for(let x=0; x<W; x++) {
            let rayAngle = (player.dir - FOV/2) + (x/W)*FOV;
            let dist = 0;
            let hit = false;
            
            let cos = Math.cos(rayAngle);
            let sin = Math.sin(rayAngle);
            
            // DDA-ish loop
            let testX = player.x; 
            let testY = player.y;
            
            let i=0;
            while(!hit && i<40) { // View distance
                dist += BLOCK/2; // Rough step
                testX = player.x + cos*dist;
                testY = player.y + sin*dist;
                
                let mx = Math.floor(testX/BLOCK);
                let my = Math.floor(testY/BLOCK);
                
                if(mx<0 || mx>=MAP_DIM || my<0 || my>=MAP_DIM || map[my*MAP_DIM+mx]===1) {
                    hit = true;
                    // Refine distance binary search style for smoother walls? 
                    // Nah, keep it raw for retro feel
                }
                i++;
            }
            
            // Fisheye fix
            let pDist = dist * Math.cos(rayAngle - player.dir);
            ZBUFFER[x] = pDist;
            
            let wallH = (BLOCK * H) / pDist;
            
            // Wall Color (Distance Shading)
            let shade = Math.max(0, 255 - pDist*0.3);
            if(hit) {
                // Red tinted walls
                ctx.fillStyle = `rgb(${shade}, ${shade*0.1}, ${shade*0.1})`; 
                ctx.fillRect(x, (H-wallH)/2, 1, wallH);
            }
        }

        // Draw Enemy (Billboard)
        let ex = enemy.x - player.x;
        let ey = enemy.y - player.y;
        let eDist = Math.sqrt(ex*ex + ey*ey);
        
        let spriteDir = Math.atan2(ey, ex) - player.dir;
        while(spriteDir < -Math.PI) spriteDir += Math.PI*2;
        while(spriteDir > Math.PI) spriteDir -= Math.PI*2;
        
        if(Math.abs(spriteDir) < FOV) {
            let screenX = (0.5 * (spriteDir/(FOV/2)) + 0.5) * W;
            let spriteH = (BLOCK * H) / eDist;
            let spriteW = spriteH;
            
            let startX = Math.floor(screenX - spriteW/2);
            let endX = Math.floor(screenX + spriteW/2);
            
            for(let sx=startX; sx<endX; sx++) {
                if(sx >= 0 && sx < W && eDist < ZBUFFER[sx]) {
                   let texX = Math.floor((sx - startX) / spriteW * spriteSize);
                   ctx.drawImage(monsterCanvas, texX, 0, 1, spriteSize, sx, (H-spriteH)/2, 1, spriteH);
                }
            }
        }
        
        // Draw Joystick HUD
        drawJoy(touchL, 40, H-40);
        drawJoy(touchR, W-40, H-40);
    }

    function drawJoy(touch, baseX, baseY) {
        if(!touch.active) return;
        // Map screen coords to low-res canvas coords
        let sX = (touch.x / window.innerWidth) * W;
        let sY = (touch.y / window.innerHeight) * H;
        
        ctx.strokeStyle = 'rgba(255,0,0,0.5)';
        ctx.beginPath(); ctx.arc(sX, sY, 15, 0, Math.PI*2); ctx.stroke();
        
        ctx.fillStyle = 'rgba(255,0,0,0.8)';
        ctx.beginPath(); ctx.arc(sX + (touch.dx/STICK_MAX)*10, sY + (touch.dy/STICK_MAX)*10, 5, 0, Math.PI*2); ctx.fill();
    }

    function renderDeath() {
        // Chaos Effect
        ctx.fillStyle = `rgb(${Math.random()*255}, 0, 0)`;
        ctx.fillRect(0, 0, W, H);
        
        // Giant Face
        let shakeX = (Math.random() - 0.5) * 50;
        let shakeY = (Math.random() - 0.5) * 50;
        ctx.drawImage(monsterCanvas, 0 + shakeX, 0 + shakeY, W, H);
        
        // Static
        for(let i=0; i<1000; i++) {
            ctx.fillStyle = Math.random()>0.5 ? '#fff' : '#000';
            ctx.fillRect(Math.random()*W, Math.random()*H, 2, 2);
        }
    }

    loop();
</script>
</body>
</html>
